<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æé†’äº‹é …æ‡‰ç”¨ç¨‹å¼</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FFF8F0; /* æš–è‰²èª¿èƒŒæ™¯ï¼šéå¸¸æ·ºçš„æ¡ƒè‰²/ç±³è‰² */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better content flow */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            max-width: 600px;
            width: 100%;
            background-color: #FFFFFF; /* å®¹å™¨èƒŒæ™¯ï¼šç™½è‰²ï¼Œå¯èˆ‡æš–è‰²èª¿å”èª¿ */
            border-radius: 16px; /* æ›´åœ“æ½¤çš„é‚Šè§’ */
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.15); /* ç¨å¾®æ›´æ˜é¡¯çš„é™°å½± */
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        .input-group {
            position: relative; /* ç”¨æ–¼åœ–æ¨™å®šä½ */
        }
        input[type="date"],
        input[type="time"],
        input[type="text"],
        select { /* é¸æ“‡æ¡†ä¹Ÿæ‡‰ç”¨æ¨£å¼ */
            padding: 12px 18px;
            padding-right: 40px; /* ç‚ºåœ–æ¨™é ç•™ç©ºé–“ */
            border-radius: 8px; /* Rounded corners for inputs/buttons */
            border: 1px solid #D1CFCF; /* æŸ”å’Œçš„æ·ºç°è‰²é‚Šæ¡† */
            font-size: 16px;
            color: #333333; /* æ·±ç°æ–‡å­— */
            background-color: #F8F8F8; /* æ·ºç°èƒŒæ™¯ */
            transition: all 0.2s ease-in-out;
            box-sizing: border-box; /* ç¢ºä¿ padding ä¸å¢åŠ å¯¬åº¦ */
        }
        .input-group .icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #7A7A7A; /* åœ–æ¨™é¡è‰² */
            pointer-events: none; /* è®“é»æ“Šèƒ½ç©¿é€åˆ°è¼¸å…¥æ¡† */
        }
        input::placeholder { /* é‡å° placeholder æ–‡å­— */
            color: #A0A0A0; /* æ·ºè‰²æ¨¡å¼ä¸‹å¯è¦‹çš„ç°è‰² */
            opacity: 1;
        }
        input:focus,
        select:focus { /* é¸æ“‡æ¡†ä¹Ÿæ‡‰ç”¨ç„¦é»æ¨£å¼ */
            outline: none;
            border-color: #FF8C00; /* äº®æ©™è‰²ç„¦é»ç’° */
            box-shadow: 0 0 0 3px rgba(255, 140, 0, 0.25);
            background-color: #FFFFFF; /* ç„¦é»æ™‚èƒŒæ™¯ç‚ºç™½è‰² */
        }
        button {
            padding: 12px 18px;
            border-radius: 8px; /* Rounded corners for buttons */
            cursor: pointer;
            background-color: #FF8C00; /* äº®æ©™è‰²æŒ‰éˆ• */
            color: white;
            font-weight: 600;
            border: none;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 8px rgba(255, 140, 0, 0.2); /* æŒ‰éˆ•é™°å½± */
        }
        button:hover {
            background-color: #E07B00; /* æ»‘é¼ æ‡¸åœæ™‚æ›´æ·±çš„æ©™è‰² */
            transform: translateY(-2px); /* ç¨å¾®æŠ¬èµ·çš„æ•ˆæœ */
            box-shadow: 0 6px 12px rgba(255, 140, 0, 0.3); /* æ›´å¤§çš„é™°å½± */
        }
        button:disabled { /* ç¦ç”¨æŒ‰éˆ•æ¨£å¼ */
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .reminder-item {
            background-color: #FFFFFF; /* æé†’äº‹é …èƒŒæ™¯ï¼šç™½è‰² */
            border: 1px solid #E5E5E5; /* æ·ºç°è‰²é‚Šæ¡† */
            padding: 18px; /* å¢åŠ å…§é‚Šè· */
            border-radius: 12px; /* æ›´åœ“æ½¤çš„é‚Šè§’ */
            display: flex;
            flex-direction: column; /* å…è¨±å…§å®¹å‚ç›´æ’åˆ— */
            gap: 10px; /* å¢åŠ è¡Œé–“è· */
            position: relative; /* ç”¨æ–¼å®šä½é‡è¦æ€§æ¨™ç±¤ */
            word-break: break-word; /* Ensure long text wraps */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08); /* é …ç›®é™°å½± */
        }
        .reminder-item .header-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* è®“é‡è¦æ€§æ¨™ç±¤åœ¨å³ä¸Šè§’ */
            width: 100%;
            gap: 10px;
        }
        .reminder-item .event-text {
            color: #333333; /* æ·±ç°æ–‡å­— */
            font-size: 1.2em; /* è®“äº‹ä»¶æ–‡å­—ç¨å¾®å¤§ä¸€é» */
            font-weight: 600;
            line-height: 1.3;
        }
        .reminder-item .details-row {
            display: flex;
            flex-wrap: wrap; /* å…§å®¹éå¤šæ™‚æ›è¡Œ */
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-top: 5px; /* èˆ‡äº‹ä»¶æ–‡å­—é–“è· */
        }
        .reminder-item .datetime-text {
            color: #666666; /* ä¸­ç°æ–‡å­— */
            font-size: 0.95em;
            flex-grow: 1; /* ä½”æ“šå¤šæ•¸ç©ºé–“ */
        }
        .delete-btn {
            background-color: #E74C3C; /* æ›´é®®è±”çš„ç´… */
            color: white;
            padding: 8px 14px; /* å¢åŠ å…§é‚Šè· */
            border-radius: 8px; /* æ›´åœ“æ½¤ */
            font-size: 0.8em;
            transition: all 0.2s ease-in-out;
            align-self: flex-end; /* å°‡åˆªé™¤æŒ‰éˆ•ç½®æ–¼å³ä¸‹è§’ */
            margin-top: 5px; /* èˆ‡ä¸Šæ–¹å…§å®¹é–“è· */
            box-shadow: 0 2px 4px rgba(231, 76, 60, 0.2);
        }
        .delete-btn:hover {
            background-color: #C0392B; /* æ›´æ·±çš„ç´… */
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(231, 76, 60, 0.3);
        }

        /* Importance styling */
        .importance-tag {
            font-size: 0.7em; /* ç¨å¾®å°ä¸€é» */
            font-weight: 700; /* æ›´ç²—çš„å­—é«” */
            padding: 4px 10px;
            border-radius: 10px; /* è† å›Šç‹€ */
            color: white;
            white-space: nowrap; /* ä¸æ›è¡Œ */
            min-width: 40px; /* æœ€å°å¯¬åº¦ */
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .importance-low {
            background-color: #28a745; /* Bootstrap green */
        }
        .importance-medium {
            background-color: #ffc107; /* Bootstrap yellow */
            color: #333333; /* æ·±è‰²æ–‡å­— */
        }
        .importance-high {
            background-color: #dc3545; /* Bootstrap red */
        }
        .repeat-text {
            font-size: 0.85em;
            color: #7A7A7A;
            margin-left: 10px; /* å¢åŠ èˆ‡å…¶ä»–æ–‡å­—çš„é–“è· */
        }

        /* Repeat options styling */
        .repeat-options {
            display: flex;
            flex-wrap: wrap; /* æ›è¡Œ */
            gap: 15px; /* å¢åŠ é–“è· */
            margin-top: 10px;
        }
        .repeat-options label {
            display: flex;
            align-items: center;
            gap: 8px; /* å¢åŠ é–“è· */
            font-size: 0.9em;
            color: #4A4A4A;
            cursor: pointer;
        }
        .repeat-options input[type="checkbox"] {
            width: 20px; /* èª¿æ•´å¤§å° */
            height: 20px;
            border: 2px solid #D1CFCF; /* é‚Šæ¡†æ›´ç²— */
            border-radius: 6px; /* æ›´åœ“æ½¤ */
            appearance: none; /* éš±è—åŸç”Ÿæ¨£å¼ */
            -webkit-appearance: none;
            -moz-appearance: none;
            cursor: pointer;
            position: relative;
            background-color: #FFFFFF;
            transition: all 0.2s ease-in-out;
            flex-shrink: 0; /* é˜²æ­¢ç¸®å° */
        }
        .repeat-options input[type="checkbox"]:checked {
            background-color: #D97940; /* é¸ä¸­æ™‚çš„èƒŒæ™¯è‰² */
            border-color: #D97940;
        }
        .repeat-options input[type="checkbox"]:checked::after {
            content: 'âœ”'; /* é¸ä¸­æ™‚çš„å‹¾è™Ÿ */
            font-size: 14px;
            color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .repeat-options input[type="checkbox"]:hover {
            border-color: #D97940; /* æ‡¸åœæ™‚æ”¹è®Šé‚Šæ¡†é¡è‰² */
        }
        .custom-repeat-days {
            margin-top: 15px; /* å¢åŠ èˆ‡ä¸Šæ–¹é–“è· */
            padding-top: 15px;
            border-top: 1px dashed #E0D4C1; /* åˆ†éš”ç·š */
            display: none; /* é è¨­éš±è— */
            flex-wrap: wrap;
            gap: 15px; /* å¢åŠ é–“è· */
        }
        .custom-repeat-days.active {
            display: flex; /* é¡¯ç¤ºæ™‚ä½¿ç”¨ flex */
        }


        /* Notification Modal */
        .notification-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0; /* Start hidden */
            pointer-events: none; /* Disable pointer events when hidden */
            transition: opacity 0.3s ease-in-out;
        }
        .notification-modal.active {
            opacity: 1;
            pointer-events: auto;
        }
        .notification-content {
            background-color: #ffffff;
            padding: 35px;
            border-radius: 12px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-20px); /* Slight initial lift */
            transition: transform 0.3s ease-in-out;
        }
        .notification-modal.active .notification-content {
            transform: translateY(0);
        }
        .notification-content h2 {
            font-size: 2em;
            color: #D97940; /* æé†’æ¨™é¡Œä½¿ç”¨æš–è‰²èª¿ */
            margin-bottom: 15px;
            font-weight: 700;
        }
        .notification-content p {
            font-size: 1.2em;
            color: #4A4A4A; /* æé†’å…§å®¹ä½¿ç”¨æš–è‰²èª¿æ·±ç° */
            margin-bottom: 25px;
        }
        .notification-content button {
            background-color: #D97940; /* æé†’æŒ‰éˆ•èˆ‡ä¸»è¦æŒ‰éˆ•é¡è‰²ç›¸åŒ */
            padding: 12px 25px;
            font-size: 1em;
            color: white; /* ç¢ºä¿æŒ‰éˆ•æ–‡å­—å¯è¦‹ */
        }
        .user-id-display {
            font-size: 0.8em;
            color: #7A7A7A; /* ç”¨æˆ¶ ID é¡¯ç¤ºç‚ºä¸­ç° */
            text-align: center;
            margin-top: 20px;
            padding: 10px;
            background-color: #F5EFE3; /* ç”¨æˆ¶ ID èƒŒæ™¯ä½¿ç”¨æ·ºç±³è‰² */
            border-radius: 8px;
            word-break: break-all; /* Allow breaking long user IDs */
        }
        /* é‡å°é é¢ä¸»è¦æ¨™é¡Œå’Œå­æ¨™é¡Œ */
        .text-gray-800 {
            color: #1f2937; /* æ¢å¾©æ·±ç°ï¼Œç¢ºä¿åœ¨æ·ºè‰²èƒŒæ™¯å¯è¦‹ */
        }
        /* é‡å°è¼¸å…¥æ¡†æ¨™ç±¤ */
        .text-gray-700 {
            color: #374151; /* æ¢å¾©ä¸­ç°ï¼Œç¢ºä¿åœ¨æ·ºè‰²èƒŒæ™¯å¯è¦‹ */
        }
        /* é‡å°ã€Œç›®å‰æ²’æœ‰æé†’äº‹é …ã€çš„æç¤º */
        .text-gray-500 {
            color: #6b7280; /* æ¢å¾©æ·ºç°ï¼Œç¢ºä¿åœ¨æ·ºè‰²èƒŒæ™¯å¯è¦‹ */
        }
        /* é‡å°è‡ªå®šç¾©æ¨¡æ…‹æ¡†çš„æ³¨æ„æ¨™é¡Œ */
        .text-orange-600 {
            color: #D97940; /* äº®æ©˜è‰² */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">æˆ‘çš„æé†’äº‹é …</h1>

        <div class="input-section flex flex-col gap-4">
            <div class="input-group">
                <label for="reminderDate" class="block text-sm font-medium text-gray-700 mb-1">æ—¥æœŸ:</label>
                <input type="date" id="reminderDate" class="w-full">
                <span class="icon">ğŸ“…</span>
            </div>
            <div class="input-group">
                <label for="reminderTime" class="block text-sm font-medium text-gray-700 mb-1">æ™‚é–“:</label>
                <input type="time" id="reminderTime" class="w-full">
                <span class="icon">â°</span>
            </div>
            <div class="input-group">
                <label for="reminderEvent" class="block text-sm font-medium text-gray-700 mb-1">äº‹ä»¶:</label>
                <input type="text" id="reminderEvent" placeholder="è¼¸å…¥æé†’äº‹ä»¶..." class="w-full">
                <span class="icon">ğŸ“</span>
            </div>

            <div>
                <label for="repeatSelect" class="block text-sm font-medium text-gray-700 mb-1">é‡è¤‡:</label>
                <select id="repeatSelect" class="w-full">
                    <option value="once">åªæé†’ä¸€æ¬¡</option>
                    <option value="daily">æ¯å¤©</option>
                    <option value="weekdays">å¹³æ—¥ (é€±ä¸€è‡³é€±äº”)</option>
                    <option value="weekends">é€±æœ« (é€±å…­ã€é€±æ—¥)</option>
                    <option value="custom">è‡ªè¨‚</option>
                </select>
            </div>

            <div id="customRepeatDaysContainer" class="custom-repeat-days">
                <label><input type="checkbox" name="customDay" value="1"> é€±ä¸€</label>
                <label><input type="checkbox" name="customDay" value="2"> é€±äºŒ</label>
                <label><input type="checkbox" name="customDay" value="3"> é€±ä¸‰</label>
                <label><input type="checkbox" name="customDay" value="4"> é€±å››</label>
                <label><input type="checkbox" name="customDay" value="5"> é€±äº”</label>
                <label><input type="checkbox" name="customDay" value="6"> é€±å…­</label>
                <label><input type="checkbox" name="customDay" value="0"> é€±æ—¥</label>
            </div>

            <div>
                <label for="importanceSelect" class="block text-sm font-medium text-gray-700 mb-1">é‡è¦ç¨‹åº¦:</label>
                <select id="importanceSelect" class="w-full">
                    <option value="low">ä½</option>
                    <option value="medium" selected>ä¸­</option>
                    <option value="high">é«˜</option>
                </select>
            </div>

            <button id="addReminderBtn" class="w-full" disabled>æ–°å¢æé†’</button>
        </div>

        <div class="reminders-list-section mt-6">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">å¾…è¾¦æé†’</h2>
            <div id="remindersList" class="flex flex-col gap-3">
                <!-- Reminders will be loaded here -->
                <p class="text-gray-500 text-center" id="noRemindersMessage">ç›®å‰æ²’æœ‰æé†’äº‹é …ã€‚</p>
            </div>
        </div>

        <div class="user-id-display">
            <p>ä½ çš„ç”¨æˆ¶ ID: <span id="currentUserId">è¼‰å…¥ä¸­...</span></p>
        </div>
    </div>

    <!-- Notification Modal -->
    <div id="notificationModal" class="notification-modal hidden">
        <div class="notification-content">
            <h2 class="text-orange-600">æé†’!</h2>
            <p id="notificationMessage">é€™æ˜¯ä¸€å€‹æé†’ã€‚</p>
            <button id="closeNotificationBtn">æˆ‘çŸ¥é“äº†</button>
        </div>
    </div>

    <!-- Firebase SDKs -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, orderBy, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Configuration - è«‹å°‡ä½ çš„ Firebase å°ˆæ¡ˆè¨­å®šè²¼åˆ°é€™è£¡
        // ==========================================================================================================
        // é‡è¦æç¤ºï¼š
        //   1. è«‹ç™»å…¥ä½ çš„ Firebase æ§åˆ¶å° (Firebase Console): https://console.firebase.google.com/
        //   2. é¸æ“‡ä½ çš„å°ˆæ¡ˆã€‚
        //   3. é»æ“Šå·¦å´å°èˆªæ¬„ä¸­çš„ "Project settings" (é½’è¼ªåœ–æ¨™)ã€‚
        //   4. åœ¨ "General" (ä¸€èˆ¬) é¸é …å¡ä¸‹ï¼Œå‘ä¸‹æ²å‹•åˆ° "Your apps" (ä½ çš„æ‡‰ç”¨ç¨‹å¼) éƒ¨åˆ†ã€‚
        //   5. å¦‚æœä½ é‚„æ²’æœ‰ Web æ‡‰ç”¨ç¨‹å¼ï¼Œè«‹é»æ“Š "Add app" (+) ä¸¦é¸æ“‡ "Web" è¨»å†Šä¸€å€‹æ–°æ‡‰ç”¨ç¨‹å¼ã€‚
        //   6. è¤‡è£½å½ˆå‡ºè¦–çª—ä¸­ `const firebaseConfig = { ... };` é€™å€‹ç‰©ä»¶çš„**æ‰€æœ‰å…§å®¹**ã€‚
        //   7. å°‡è¤‡è£½çš„å…§å®¹ï¼Œå®Œæ•´åœ°è²¼åˆ°ä¸‹æ–¹ `firebaseConfig` ç‰©ä»¶çš„èŠ±æ‹¬è™Ÿ `{}` å…§ã€‚
        //
        // ç¯„ä¾‹ (è«‹æ›¿æ›ç‚ºä½ è‡ªå·±çš„å¯¦éš›è³‡è¨Š):
        // const firebaseConfig = {
        //   apiKey: "AIzaSyD-Your-API-Key",
        //   authDomain: "your-project-id.firebaseapp.com",
        //   projectId: "your-project-id",
        //   storageBucket: "your-project-id.appspot.com",
        //   messagingSenderId: "1234567890",
        //   appId: "1:1234567890:web:abcdef1234567890abcdef"
        // };
        // ==========================================================================================================
        const firebaseConfig = {// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAnalytics } from "firebase/analytics";
// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
  apiKey: "AIzaSyC3UOA5P7Fl6FMBaUMpn00AcAG_o_LRfIY",
  authDomain: "the-protject.firebaseapp.com",
  projectId: "the-protject",
  storageBucket: "the-protject.firebasestorage.app",
  messagingSenderId: "623378750946",
  appId: "1:623378750946:web:4f759e84a280267bdd2dbb",
  measurementId: "G-C1MQSWFHVS"
};

// Initialize Firebase
const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app);
        };


        // Global variables for Firebase and user
        let app;
        let db;
        let auth;
        let userId;
        let reminders = []; // Array to store reminder objects
        const scheduledTimeouts = new Map(); // Map to store timeout IDs for clearing
        let isFirebaseReady = false; // æ–°å¢æ——æ¨™ï¼Œè¿½è¹¤ Firebase æ˜¯å¦å·²æº–å‚™å°±ç·’

        // DOM element references
        const reminderDateInput = document.getElementById('reminderDate');
        const reminderTimeInput = document.getElementById('reminderTime');
        const reminderEventInput = document.getElementById('reminderEvent');
        const repeatSelect = document.getElementById('repeatSelect');
        const customRepeatDaysContainer = document.getElementById('customRepeatDaysContainer');
        const customDayCheckboxes = document.querySelectorAll('input[name="customDay"]');
        const importanceSelect = document.getElementById('importanceSelect');
        const addReminderBtn = document.getElementById('addReminderBtn');
        const remindersList = document.getElementById('remindersList');
        const noRemindersMessage = document.getElementById('noRemindersMessage');
        const notificationModal = document.getElementById('notificationModal');
        const notificationMessage = document.getElementById('notificationMessage');
        const closeNotificationBtn = document.getElementById('closeNotificationBtn');
        const currentUserIdSpan = document.getElementById('currentUserId');

        // Function to set the current date and time in the input fields
        function setInitialDateTime() {
            const now = new Date();

            // Format date toà´ªàµà´ªàµ†à´Ÿàµ†-MM-DD
            const year = now.getFullYear();
            const month = (now.getMonth() + 1).toString().padStart(2, '0'); // Months are 0-indexed
            const day = now.getDate().toString().padStart(2, '0');
            reminderDateInput.value = `${year}-${month}-${day}`;

            // Format time to HH:MM
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            reminderTimeInput.value = `${hours}:${minutes}`;
        }

        // Function to toggle custom repeat days visibility
        function toggleCustomRepeatDays() {
            if (repeatSelect.value === 'custom') {
                customRepeatDaysContainer.classList.add('active');
            } else {
                customRepeatDaysContainer.classList.remove('active');
                // Uncheck all custom day checkboxes when not in custom mode
                customDayCheckboxes.forEach(checkbox => checkbox.checked = false);
            }
        }

        // Initialize Firebase and set up authentication
        async function initializeFirebase() {
            try {
                // Determine the correct Firebase config to use.
                // In Canvas, __firebase_config is provided. Outside Canvas (e.g., GitHub Pages), use the hardcoded firebaseConfig.
                const configToUse = typeof __firebase_config !== 'undefined' && Object.keys(JSON.parse(__firebase_config)).length > 0
                                   ? JSON.parse(__firebase_config)
                                   : firebaseConfig;

                // Validate if configToUse is empty, which means user hasn't provided their firebaseConfig yet.
                if (!configToUse || Object.keys(configToUse).length === 0 || !configToUse.projectId) {
                    throw new Error("Firebase configuration is missing or incomplete. Please add your Firebase project config to the code.");
                }

                // Determine the appId. Use __app_id if available, otherwise fallback to projectId from the config.
                // This `currentAppId` will be consistent for all Firestore paths.
                const currentAppId = typeof __app_id !== 'undefined' ? __app_id : configToUse.projectId;

                // Initialize Firebase app
                app = initializeApp(configToUse);
                db = getFirestore(app);
                auth = getAuth(app);

                // Sign in the user
                if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                    await signInWithCustomToken(auth, __initial_auth_token);
                } else {
                    await signInAnonymously(auth);
                }

                // Listen for auth state changes
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        currentUserIdSpan.textContent = userId;
                        console.log("Firebase initialized. User ID:", userId);
                        setupFirestoreListener(currentAppId); // Pass appId to listener
                        isFirebaseReady = true; // Firebase æº–å‚™å°±ç·’
                        addReminderBtn.disabled = false; // å•Ÿç”¨æ–°å¢æŒ‰éˆ•
                    } else {
                        // If user is signed out, create a random ID. This should ideally not happen if signInAnonymously succeeds.
                        userId = crypto.randomUUID();
                        currentUserIdSpan.textContent = `åŒ¿åç”¨æˆ¶ (${userId})`;
                        console.log("Firebase initialized. Anonymous User ID:", userId);
                        setupFirestoreListener(currentAppId); // Still try to load data, though it might be empty
                        isFirebaseReady = true; // Firebase æº–å‚™å°±ç·’
                        addReminderBtn.disabled = false; // å•Ÿç”¨æ–°å¢æŒ‰éˆ•
                    }
                });
            } catch (error) {
                console.error("Error initializing Firebase:", error);
                currentUserIdSpan.textContent = `è¼‰å…¥å¤±æ•—: ${error.message || 'è«‹æª¢æŸ¥æ‚¨çš„ Firebase è¨­å®šå’Œç¶²è·¯é€£ç·šã€‚'}`;
                addReminderBtn.disabled = true; // ä¿æŒç¦ç”¨æŒ‰éˆ•
                showCustomModal(`æ‡‰ç”¨ç¨‹å¼åˆå§‹åŒ–å¤±æ•—ï¼\n\néŒ¯èª¤ï¼š${error.message || 'æœªçŸ¥éŒ¯èª¤ã€‚è«‹ç¢ºä¿æ‚¨çš„ Firebase è¨­å®šæ­£ç¢ºç„¡èª¤ã€‚'}\n\nè«‹æŒ‰ç…§èªªæ˜åœ¨ç¨‹å¼ç¢¼ä¸­è²¼ä¸Šæ‚¨çš„ Firebase å°ˆæ¡ˆé…ç½®ã€‚`);
            }
        }

        // Set up real-time listener for reminders from Firestore
        // Pass appId to this function so it's consistent with initialization
        function setupFirestoreListener(appId) {
            if (!userId) {
                console.warn("User ID not available yet for Firestore listener.");
                return;
            }
            // Use the passed appId to construct the collection path
            const remindersCollectionRef = collection(db, `artifacts/${appId}/users/${userId}/reminders`);
            // Use onSnapshot to listen for real-time updates
            onSnapshot(remindersCollectionRef, (snapshot) => {
                const newReminders = [];
                snapshot.forEach((doc) => {
                    newReminders.push({ id: doc.id, ...doc.data() });
                });

                // Clear all previously scheduled timeouts
                scheduledTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
                scheduledTimeouts.clear();

                // Sort reminders by timestamp
                reminders = newReminders.sort((a, b) => a.timestamp - b.timestamp);
                renderReminders();
                reminders.forEach(scheduleReminder); // Reschedule all reminders
            }, (error) => {
                console.error("Error fetching reminders:", error);
                showCustomModal(`ç„¡æ³•è¼‰å…¥æé†’äº‹é …ï¼\n\néŒ¯èª¤ï¼š${error.message || 'æœªçŸ¥éŒ¯èª¤ã€‚'}\n\nè«‹æª¢æŸ¥æ‚¨çš„ Firebase æ¬Šé™è¨­å®šã€‚`);
            });
        }

        /**
         * Calculates the next *future* occurrence of a reminder (especially for repeating ones).
         * This function ensures the returned timestamp is always in the future relative to the current time.
         * @param {object} reminder - The reminder object with original timestamp, repeatType, etc.
         * @returns {object|null} An object with `newTimestamp`, `newDateStr`, `newTimeStr` or null if no future occurrence can be found.
         */
        function calculateNextOccurrence(reminder) {
            const originalHour = new Date(reminder.timestamp).getHours();
            const originalMinute = new Date(reminder.timestamp).getMinutes();
            const now = new Date();

            let candidateDate = new Date(); // Start checking from current date
            candidateDate.setHours(originalHour, originalMinute, 0, 0); // Set time to reminder's original time

            // If today's reminder time (original hour:minute) is already past/current, advance to tomorrow.
            // This ensures we always start looking for a future date.
            if (candidateDate.getTime() <= now.getTime()) {
                candidateDate.setDate(candidateDate.getDate() + 1);
            }

            let foundNext = false;
            const maxSearchDays = 366 * 2; // Search up to 2 years to ensure we find a valid day for repeats

            for (let i = 0; i < maxSearchDays; i++) {
                // If it's not the first iteration, advance by one day.
                // This ensures we always check the current candidateDate *before* advancing for the next iteration.
                if (i > 0) {
                     candidateDate.setDate(candidateDate.getDate() + 1);
                }

                const dayOfWeek = candidateDate.getDay(); // 0 for Sunday, 6 for Saturday

                let isValidDayForRepeatType = false;
                switch (reminder.repeatType) {
                    case 'daily':
                        isValidDayForRepeatType = true;
                        break;
                    case 'weekdays':
                        isValidDayForRepeatType = (dayOfWeek >= 1 && dayOfWeek <= 5); // Monday to Friday
                        break;
                    case 'weekends':
                        isValidDayForRepeatType = (dayOfWeek === 0 || dayOfWeek === 6); // Sunday or Saturday
                        break;
                    case 'custom':
                        isValidDayForRepeatType = reminder.customRepeatDays && reminder.customRepeatDays.length > 0 && reminder.customRepeatDays.includes(dayOfWeek);
                        break;
                    case 'once':
                        // This function is primarily for repeating reminders.
                        // For 'once', if its original timestamp is already past 'now', there's no 'next' occurrence.
                        // If it's still in the future, its own timestamp is the 'next' occurrence.
                        // So we only return it if it's strictly in the future relative to the point this function is called.
                        // This case should ideally not be hit for 'once' reminders that need rescheduling,
                        // as they are simply deleted after firing.
                        // However, if we get here during an 'add' operation for a past 'once' reminder, it means an invalid state.
                        return null;
                    default:
                        // Should not happen for valid repeat types
                        return null;
                }

                // After setting the candidateDate to the appropriate day, and if it's a valid day type,
                // check if its specific time (original hour:minute) is in the future.
                if (isValidDayForRepeatType && candidateDate.getTime() > now.getTime()) {
                    foundNext = true;
                    break;
                }
            }

            if (!foundNext) {
                console.warn("Could not find a future occurrence for repeating reminder after many iterations:", reminder);
                return null;
            }

            // Format the new date and time
            const newYear = candidateDate.getFullYear();
            const newMonth = (candidateDate.getMonth() + 1).toString().padStart(2, '0');
            const newDay = candidateDate.getDate().toString().padStart(2, '0');
            const newHours = candidateDate.getHours().toString().padStart(2, '0');
            const newMinutes = candidateDate.getMinutes().toString().padStart(2, '0');

            return {
                newTimestamp: candidateDate.getTime(),
                newDateStr: `${newYear}-${newMonth}-${newDay}`,
                newTimeStr: `${newHours}:${newMinutes}`
            };
        }

        // Function to add a new reminder
        async function addReminder() {
            // åœ¨åŸ·è¡Œ Firebase æ“ä½œå‰ï¼Œæª¢æŸ¥æ˜¯å¦å·²æº–å‚™å°±ç·’
            if (!isFirebaseReady || !db || !userId) {
                showCustomModal("æ‡‰ç”¨ç¨‹å¼æ­£åœ¨è¼‰å…¥ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚");
                return;
            }

            const dateStr = reminderDateInput.value;
            const timeStr = reminderTimeInput.value;
            const eventText = reminderEventInput.value.trim();
            const repeatType = repeatSelect.value;
            const importance = importanceSelect.value;
            let customRepeatDays = [];

            if (repeatType === 'custom') {
                customDayCheckboxes.forEach(checkbox => {
                    if (checkbox.checked) {
                        customRepeatDays.push(parseInt(checkbox.value, 10));
                    }
                });
                if (customRepeatDays.length === 0) {
                    showCustomModal("è«‹ç‚ºè‡ªè¨‚é‡è¤‡æé†’é¸æ“‡è‡³å°‘ä¸€å¤©ï¼");
                    return;
                }
            }

            if (!dateStr || !timeStr || !eventText) {
                showCustomModal("è«‹å¡«å¯«æ—¥æœŸã€æ™‚é–“å’Œäº‹ä»¶å…§å®¹ï¼");
                return;
            }

            const reminderDateTime = new Date(`${dateStr}T${timeStr}`);
            const now = new Date();

            // Initial validation for 'once' reminders: cannot be in the past.
            if (repeatType === 'once' && reminderDateTime.getTime() <= now.getTime()) {
                showCustomModal("å–®æ¬¡æé†’æ™‚é–“å¿…é ˆæ™šæ–¼ç¾åœ¨ï¼");
                return;
            }

            const newReminder = {
                event: eventText,
                date: dateStr,
                time: timeStr,
                timestamp: reminderDateTime.getTime(), // Initial timestamp from user input
                repeatType: repeatType,
                customRepeatDays: customRepeatDays,
                importance: importance,
                createdAt: Date.now()
            };

            // If it's a repeating reminder AND its initial timestamp is in the past,
            // calculate its first actual future occurrence and update the object before saving.
            if (newReminder.repeatType !== 'once' && newReminder.timestamp <= now.getTime()) {
                const nextOcc = calculateNextOccurrence(newReminder); // This call will find the next future occurrence
                if (nextOcc) {
                    newReminder.timestamp = nextOcc.newTimestamp;
                    newReminder.date = nextOcc.newDateStr;
                    newReminder.time = nextOcc.newTimeStr;
                    console.log("Repeating reminder adjusted to next occurrence during add:", nextOcc);
                } else {
                    // This scenario means a repeating reminder set in the past cannot find *any* future valid occurrence
                    // within the search limit (e.g., all custom days are in the past for 2 years).
                    // This is likely a misconfiguration or a very long-term past reminder.
                    showCustomModal("ç„¡æ³•ç‚ºé‡è¤‡æé†’æ‰¾åˆ°æœªä¾†çš„æ™‚é–“ï¼Œè«‹æª¢æŸ¥è¨­å®šï¼");
                    return;
                }
            }


            try {
                // å¾å·²åˆå§‹åŒ–çš„ app ç‰©ä»¶ä¸­ç²å– projectId ä½œç‚º appIdï¼Œé€™æ›´å¯é 
                const effectiveAppId = app.options.projectId;
                if (!effectiveAppId) {
                    throw new Error("Application ID is not available for Firestore operations. Firebase may not be initialized correctly.");
                }

                const docRef = await addDoc(collection(db, `artifacts/${effectiveAppId}/users/${userId}/reminders`), newReminder);
                console.log("Reminder added with ID: ", docRef.id, newReminder);

                // Clear input fields and reset selects
                setInitialDateTime(); // Reset date/time to current
                reminderEventInput.value = '';
                repeatSelect.value = 'once';
                importanceSelect.value = 'medium';
                toggleCustomRepeatDays(); // Hide custom days again
            } catch (e) {
                console.error("Error adding document: ", e);
                showCustomModal("æ–°å¢æé†’å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–ç¨å¾Œå†è©¦ã€‚");
            }
        }

        // Function to render the list of reminders
        function renderReminders() {
            remindersList.innerHTML = ''; // Clear existing list
            if (reminders.length === 0) {
                noRemindersMessage.style.display = 'block';
            } else {
                noRemindersMessage.style.display = 'none';
                reminders.forEach(reminder => {
                    const reminderItem = document.createElement('div');
                    reminderItem.className = 'reminder-item';

                    // Add importance class
                    if (reminder.importance) {
                        reminderItem.classList.add(`importance-${reminder.importance}`);
                    }

                    // Determine repeat text
                    let repeatText = '';
                    switch (reminder.repeatType) {
                        case 'once': repeatText = 'ä¸€æ¬¡'; break;
                        case 'daily': repeatText = 'æ¯å¤©é‡è¤‡'; break;
                        case 'weekdays': repeatText = 'å¹³æ—¥é‡è¤‡'; break;
                        case 'weekends': repeatText = 'é€±æœ«é‡è¤‡'; break;
                        case 'custom':
                            if (reminder.customRepeatDays && reminder.customRepeatDays.length > 0) {
                                const dayNames = ['é€±æ—¥', 'é€±ä¸€', 'é€±äºŒ', 'é€±ä¸‰', 'é€±å››', 'é€±äº”', 'é€±å…­'];
                                const selectedDays = reminder.customRepeatDays.map(day => dayNames[day]).join('ã€');
                                repeatText = `è‡ªè¨‚é‡è¤‡: ${selectedDays}`;
                            } else {
                                repeatText = 'è‡ªè¨‚é‡è¤‡ (æœªè¨­å®š)';
                            }
                            break;
                    }


                    reminderItem.innerHTML = `
                        <div class="header-row">
                            <span class="event-text flex-grow">${reminder.event}</span>
                            <span class="importance-tag importance-${reminder.importance}">${reminder.importance === 'low' ? 'ä½' : (reminder.importance === 'medium' ? 'ä¸­' : 'é«˜')}</span>
                        </div>
                        <div class="details-row">
                            <span class="datetime-text">${reminder.date} ${reminder.time}</span>
                            <span class="repeat-text">é‡è¤‡: ${repeatText}</span>
                            <button class="delete-btn" data-id="${reminder.id}">åˆªé™¤</button>
                        </div>
                    `;
                    remindersList.appendChild(reminderItem);
                });
            }
        }

        // Function to play a simple beep sound using Web Audio API
        function playBeepSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = 'sine'; // Sine wave for a clean beep
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note (440 Hz)

                gainNode.gain.setValueAtTime(1, audioContext.currentTime);
                // Exponential ramp to 0.001 (near silent) over 0.5 seconds
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5); // Play for 0.5 seconds
            } catch (e) {
                console.error("Error playing beep sound:", e);
                // Optionally show a visual alert if sound fails, but console error is usually enough
            }
        }


        // Function to schedule a single reminder
        async function scheduleReminder(reminder) {
            // Clear existing timeout for this reminder if it was rescheduled or updated
            if (scheduledTimeouts.has(reminder.id)) {
                clearTimeout(scheduledTimeouts.get(reminder.id));
                scheduledTimeouts.delete(reminder.id);
            }

            const now = Date.now();
            let delay = reminder.timestamp - now;

            // Handle reminders that are already past or current
            if (delay <= 0) {
                if (reminder.repeatType !== 'once') {
                    // For repeating reminders: find the next future occurrence
                    const nextOcc = calculateNextOccurrence(reminder);
                    if (nextOcc) {
                        console.log(`Repeating reminder "${reminder.event}" is past/current. Rescheduling to:`, nextOcc.newDateStr, nextOcc.newTimeStr);
                        // Determine the correct appId for Firestore collection path during update.
                        const effectiveAppId = app.options.projectId;
                        if (!effectiveAppId) {
                            console.error("Application ID is not available for Firestore update operation.");
                            return;
                        }
                        await updateDoc(doc(db, `artifacts/${effectiveAppId}/users/${userId}/reminders`, reminder.id), {
                            timestamp: nextOcc.newTimestamp,
                            date: nextOcc.newDateStr,
                            time: nextOcc.newTimeStr
                        });
                        return; // Update will trigger onSnapshot, which will call scheduleReminder again.
                    } else {
                        console.log(`Repeating reminder "${reminder.event}" has no future occurrences or is misconfigured. Deleting.`);
                        await deleteReminder(reminder.id);
                        return;
                    }
                } else {
                    // For one-time reminders: if past, delete it.
                    console.log(`One-time reminder "${reminder.event}" is past. Deleting.`);
                    await deleteDoc(doc(db, `artifacts/${app.options.projectId}/users/${userId}/reminders`, reminder.id)); // Use app.options.projectId
                    return;
                }
            }

            // Schedule the reminder if it's still in the future
            if (delay > 0) {
                const timeoutId = setTimeout(async () => {
                    showNotification(reminder);
                    playBeepSound(); // Play sound when notification appears

                    if (reminder.repeatType !== 'once') {
                        // For repeating reminders: after firing, calculate and update to the next occurrence
                        const nextOcc = calculateNextOccurrence(reminder);
                        if (nextOcc) {
                            console.log(`Reminder "${reminder.event}" fired. Scheduling next occurrence:`, nextOcc.newDateStr, nextOcc.newTimeStr);
                            // Determine the correct appId for Firestore collection path during update.
                            const effectiveAppId = app.options.projectId;
                            if (!effectiveAppId) {
                                console.error("Application ID is not available for Firestore update operation after fire.");
                                return;
                            }
                            await updateDoc(doc(db, `artifacts/${effectiveAppId}/users/${userId}/reminders`, reminder.id), {
                                timestamp: nextOcc.newTimestamp,
                                date: nextOcc.newDateStr,
                                time: nextOcc.newTimeStr
                            });
                        } else {
                            console.log(`Repeating reminder "${reminder.event}" has no further occurrences. Deleting.`);
                            await deleteReminder(reminder.id);
                        }
                    } else {
                        // For 'once' reminders: delete after notification
                        console.log(`One-time reminder "${reminder.event}" fired. Deleting.`);
                        await deleteDoc(doc(db, `artifacts/${app.options.projectId}/users/${userId}/reminders`, reminder.id)); // Use app.options.projectId
                    }
                }, delay);
                scheduledTimeouts.set(reminder.id, timeoutId);
            }
        }

        // Function to show the notification modal
        function showNotification(reminder) {
            notificationMessage.textContent = `ã€Œ${reminder.event}ã€æ–¼ ${reminder.date} ${reminder.time} åˆ°æœŸäº†ï¼`;
            notificationModal.classList.remove('hidden');
            notificationModal.classList.add('active');
        }

        // Function to show a custom modal for alert messages (replaces native alert)
        function showCustomModal(message) {
            const customModal = document.createElement('div');
            customModal.className = 'notification-modal active'; // Reuse notification modal styling
            customModal.innerHTML = `
                <div class="notification-content">
                    <h2 class="text-orange-600">æ³¨æ„!</h2>
                    <p>${message}</p>
                    <button id="customModalCloseBtn">ç¢ºèª</button>
                </div>
            `;
            document.body.appendChild(customModal);

            const customModalCloseBtn = customModal.querySelector('#customModalCloseBtn');
            customModalCloseBtn.addEventListener('click', () => {
                customModal.classList.remove('active');
                setTimeout(() => customModal.remove(), 300); // Remove after transition
            });
        }

        // Function to delete a reminder
        async function deleteReminder(id) {
            try {
                // Clear the scheduled timeout if it exists
                if (scheduledTimeouts.has(id)) {
                    clearTimeout(scheduledTimeouts.get(id));
                    scheduledTimeouts.delete(id);
                }

                // Determine the correct appId for Firestore collection path during delete.
                const effectiveAppId = app.options.projectId;
                if (!effectiveAppId) {
                    console.error("Application ID is not available for Firestore delete operation.");
                    return;
                }

                // Delete from Firestore
                await deleteDoc(doc(db, `artifacts/${effectiveAppId}/users/${userId}/reminders`, id));
                console.log("Reminder successfully deleted!");

                // onSnapshot listener will automatically re-render
            } catch (e) {
                console.error("Error removing document: ", e);
                showCustomModal("åˆªé™¤æé†’å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç¶²è·¯é€£ç·šæˆ–ç¨å¾Œå†è©¦ã€‚");
            }
        }

        // Event listeners
        addReminderBtn.addEventListener('click', addReminder);
        repeatSelect.addEventListener('change', toggleCustomRepeatDays);
        closeNotificationBtn.addEventListener('click', () => {
            notificationModal.classList.add('hidden');
            notificationModal.classList.remove('active');
        });

        // Event delegation for delete buttons in the list
        remindersList.addEventListener('click', (event) => {
            if (event.target.classList.contains('delete-btn')) {
                const reminderId = event.target.dataset.id;
                deleteReminder(reminderId);
            }
        });

        // Initialize Firebase and set initial date/time when the window loads
        window.onload = () => {
            setInitialDateTime(); // Set date and time when the page loads
            toggleCustomRepeatDays(); // Set initial visibility for custom repeat days
            initializeFirebase();
        };
    </script>
</body>
</html>

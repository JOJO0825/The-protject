<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æé†’äº‹é …æ‡‰ç”¨ç¨‹å¼</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    fontFamily: {
                        inter: ['Inter', 'sans-serif'],
                    },
                }
            }
        }
    </script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #FFF8F0; /* æš–è‰²èª¿èƒŒæ™¯ï¼šéå¸¸æ·ºçš„æ¡ƒè‰²/ç±³è‰² */
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align to top for better content flow */
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .container {
            max-width: 600px;
            width: 100%;
            background-color: #FFFFFF; /* å®¹å™¨èƒŒæ™¯ï¼šç™½è‰²ï¼Œå¯èˆ‡æš–è‰²èª¿å”èª¿ */
            border-radius: 16px; /* æ›´åœ“æ½¤çš„é‚Šè§’ */
            box-shadow: 0 12px 25px rgba(0, 0, 0, 0.15); /* ç¨å¾®æ›´æ˜é¡¯çš„é™°å½± */
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 25px;
        }
        .input-group {
            position: relative; /* ç”¨æ–¼åœ–æ¨™å®šä½ */
        }
        input[type="date"],
        input[type="time"],
        input[type="text"],
        select { /* é¸æ“‡æ¡†ä¹Ÿæ‡‰ç”¨æ¨£å¼ */
            padding: 12px 18px;
            padding-right: 40px; /* ç‚ºåœ–æ¨™é ç•™ç©ºé–“ */
            border-radius: 8px; /* Rounded corners for inputs/buttons */
            border: 1px solid #D1CFCF; /* æŸ”å’Œçš„æ·ºç°è‰²é‚Šæ¡† */
            font-size: 16px;
            color: #333333; /* æ·±ç°æ–‡å­— */
            background-color: #F8F8F8; /* æ·ºç°èƒŒæ™¯ */
            transition: all 0.2s ease-in-out;
            box-sizing: border-box; /* ç¢ºä¿ padding ä¸å¢åŠ å¯¬åº¦ */
        }
        .input-group .icon {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: #7A7A7A; /* åœ–æ¨™é¡è‰² */
            pointer-events: none; /* è®“é»æ“Šèƒ½ç©¿é€åˆ°è¼¸å…¥æ¡† */
        }
        input::placeholder { /* é‡å° placeholder æ–‡å­— */
            color: #A0A0A0; /* æ·ºè‰²æ¨¡å¼ä¸‹å¯è¦‹çš„ç°è‰² */
            opacity: 1;
        }
        input:focus,
        select:focus { /* é¸æ“‡æ¡†ä¹Ÿæ‡‰ç”¨ç„¦é»æ¨£å¼ */
            outline: none;
            border-color: #FF8C00; /* äº®æ©™è‰²ç„¦é»ç’° */
            box-shadow: 0 0 0 3px rgba(255, 140, 0, 0.25);
            background-color: #FFFFFF; /* ç„¦é»æ™‚èƒŒæ™¯ç‚ºç™½è‰² */
        }
        button {
            padding: 12px 18px;
            border-radius: 8px; /* Rounded corners for buttons */
            cursor: pointer;
            background-color: #FF8C00; /* äº®æ©™è‰²æŒ‰éˆ• */
            color: white;
            font-weight: 600;
            border: none;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 8px rgba(255, 140, 0, 0.2); /* æŒ‰éˆ•é™°å½± */
        }
        button:hover {
            background-color: #E07B00; /* æ»‘é¼ æ‡¸åœæ™‚æ›´æ·±çš„æ©™è‰² */
            transform: translateY(-2px); /* ç¨å¾®æŠ¬èµ·çš„æ•ˆæœ */
            box-shadow: 0 6px 12px rgba(255, 140, 0, 0.3); /* æ›´å¤§çš„é™°å½± */
        }
        /* ç¦ç”¨æŒ‰éˆ•æ¨£å¼ (å¦‚æœéœ€è¦ï¼Œé›–ç„¶é›¢ç·šæ¨¡å¼é è¨­å•Ÿç”¨) */
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        .reminder-item {
            background-color: #FFFFFF; /* æé†’äº‹é …èƒŒæ™¯ï¼šç™½è‰² */
            border: 1px solid #E5E5E5; /* æ·ºç°è‰²é‚Šæ¡† */
            padding: 18px; /* å¢åŠ å…§é‚Šè· */
            border-radius: 12px; /* æ›´åœ“æ½¤çš„é‚Šè§’ */
            display: flex;
            flex-direction: column; /* å…è¨±å…§å®¹å‚ç›´æ’åˆ— */
            gap: 10px; /* å¢åŠ è¡Œé–“è· */
            position: relative; /* ç”¨æ–¼å®šä½é‡è¦æ€§æ¨™ç±¤ */
            word-break: break-word; /* Ensure long text wraps */
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.08); /* é …ç›®é™°å½± */
        }
        .reminder-item .header-row {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; /* è®“é‡è¦æ€§æ¨™ç±¤åœ¨å³ä¸Šè§’ */
            width: 100%;
            gap: 10px;
        }
        .reminder-item .event-text {
            color: #333333; /* æ·±ç°æ–‡å­— */
            font-size: 1.2em; /* è®“äº‹ä»¶æ–‡å­—ç¨å¾®å¤§ä¸€é» */
            font-weight: 600;
            line-height: 1.3;
        }
        .reminder-item .details-row {
            display: flex;
            flex-wrap: wrap; /* å…§å®¹éå¤šæ™‚æ›è¡Œ */
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-top: 5px; /* èˆ‡äº‹ä»¶æ–‡å­—é–“è· */
        }
        .reminder-item .datetime-text {
            color: #666666; /* ä¸­ç°æ–‡å­— */
            font-size: 0.95em;
            flex-grow: 1; /* ä½”æ“šå¤šæ•¸ç©ºé–“ */
        }
        .delete-btn {
            background-color: #E74C3C; /* æ›´é®®è±”çš„ç´… */
            color: white;
            padding: 8px 14px; /* å¢åŠ å…§é‚Šè· */
            border-radius: 8px; /* æ›´åœ“æ½¤ */
            font-size: 0.8em;
            transition: all 0.2s ease-in-out;
            align-self: flex-end; /* å°‡åˆªé™¤æŒ‰éˆ•ç½®æ–¼å³ä¸‹è§’ */
            margin-top: 5px; /* èˆ‡ä¸Šæ–¹å…§å®¹é–“è· */
            box-shadow: 0 2px 4px rgba(231, 76, 60, 0.2);
        }
        .delete-btn:hover {
            background-color: #C0392B; /* æ›´æ·±çš„ç´… */
            transform: translateY(-1px);
            box-shadow: 0 3px 6px rgba(231, 76, 60, 0.3);
        }

        /* Importance styling */
        .importance-tag {
            font-size: 0.7em; /* ç¨å¾®å°ä¸€é» */
            font-weight: 700; /* æ›´ç²—çš„å­—é«” */
            padding: 4px 10px;
            border-radius: 10px; /* è† å›Šç‹€ */
            color: white;
            white-space: nowrap; /* ä¸æ›è¡Œ */
            min-width: 40px; /* æœ€å°å¯¬åº¦ */
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .importance-low {
            background-color: #28a745; /* Bootstrap green */
        }
        .importance-medium {
            background-color: #ffc107; /* Bootstrap yellow */
            color: #333333; /* æ·±è‰²æ–‡å­— */
        }
        .importance-high {
            background-color: #dc3545; /* Bootstrap red */
        }
        .repeat-text {
            font-size: 0.85em;
            color: #7A7A7A;
            margin-left: 10px; /* å¢åŠ èˆ‡å…¶ä»–æ–‡å­—çš„é–“è· */
        }

        /* Repeat options styling */
        .repeat-options {
            display: flex;
            flex-wrap: wrap; /* æ›è¡Œ */
            gap: 15px; /* å¢åŠ é–“è· */
            margin-top: 10px;
        }
        .repeat-options label {
            display: flex;
            align-items: center;
            gap: 8px; /* å¢åŠ é–“è· */
            font-size: 0.9em;
            color: #4A4A4A;
            cursor: pointer;
        }
        .repeat-options input[type="checkbox"] {
            width: 20px; /* èª¿æ•´å¤§å° */
            height: 20px;
            border: 2px solid #D1CFCF; /* é‚Šæ¡†æ›´ç²— */
            border-radius: 6px; /* æ›´åœ“æ½¤ */
            appearance: none; /* éš±è—åŸç”Ÿæ¨£å¼ */
            -webkit-appearance: none;
            -moz-appearance: none;
            cursor: pointer;
            position: relative;
            background-color: #FFFFFF;
            transition: all 0.2s ease-in-out;
            flex-shrink: 0; /* é˜²æ­¢ç¸®å° */
        }
        .repeat-options input[type="checkbox"]:checked {
            background-color: #D97940; /* é¸ä¸­æ™‚çš„èƒŒæ™¯è‰² */
            border-color: #D97940;
        }
        .repeat-options input[type="checkbox"]:checked::after {
            content: 'âœ”'; /* é¸ä¸­æ™‚çš„å‹¾è™Ÿ */
            font-size: 14px;
            color: white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        .repeat-options input[type="checkbox"]:hover {
            border-color: #D97940; /* æ‡¸åœæ™‚æ”¹è®Šé‚Šæ¡†é¡è‰² */
        }
        .custom-repeat-days {
            margin-top: 15px; /* å¢åŠ èˆ‡ä¸Šæ–¹é–“è· */
            padding-top: 15px;
            border-top: 1px dashed #E0D4C1; /* åˆ†éš”ç·š */
            display: none; /* é è¨­éš±è— */
            flex-wrap: wrap;
            gap: 15px; /* å¢åŠ é–“è· */
        }
        .custom-repeat-days.active {
            display: flex; /* é¡¯ç¤ºæ™‚ä½¿ç”¨ flex */
        }


        /* Notification Modal */
        .notification-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent background */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0; /* Start hidden */
            pointer-events: none; /* Disable pointer events when hidden */
            transition: opacity 0.3s ease-in-out;
        }
        .notification-modal.active {
            opacity: 1;
            pointer-events: auto;
        }
        .notification-content {
            background-color: #ffffff;
            padding: 35px;
            border-radius: 12px;
            box-shadow: 0 15px 30px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 400px;
            width: 90%;
            transform: translateY(-20px); /* Slight initial lift */
            transition: transform 0.3s ease-in-out;
        }
        .notification-modal.active .notification-content {
            transform: translateY(0);
        }
        .notification-content h2 {
            font-size: 2em;
            color: #D97940; /* æé†’æ¨™é¡Œä½¿ç”¨æš–è‰²èª¿ */
            margin-bottom: 15px;
            font-weight: 700;
        }
        .notification-content p {
            font-size: 1.2em;
            color: #4A4A4A; /* æé†’å…§å®¹ä½¿ç”¨æš–è‰²èª¿æ·±ç° */
            margin-bottom: 25px;
        }
        .notification-content button {
            background-color: #D97940; /* æé†’æŒ‰éˆ•èˆ‡ä¸»è¦æŒ‰éˆ•é¡è‰²ç›¸åŒ */
            padding: 12px 25px;
            font-size: 1em;
            color: white; /* ç¢ºä¿æŒ‰éˆ•æ–‡å­—å¯è¦‹ */
        }
        .user-id-display {
            /* åœ¨é›¢ç·šæ¨¡å¼ä¸‹ï¼Œé€™å€‹å€å¡Šå°‡è¢«ç§»é™¤ï¼Œå› æ­¤å…¶æ¨£å¼ä¸å†éœ€è¦ */
            display: none;
        }
        /* é‡å°é é¢ä¸»è¦æ¨™é¡Œå’Œå­æ¨™é¡Œ */
        .text-gray-800 {
            color: #1f2937; /* æ¢å¾©æ·±ç°ï¼Œç¢ºä¿åœ¨æ·ºè‰²èƒŒæ™¯å¯è¦‹ */
        }
        /* é‡å°è¼¸å…¥æ¡†æ¨™ç±¤ */
        .text-gray-700 {
            color: #374151; /* æ¢å¾©ä¸­ç°ï¼Œç¢ºä¿åœ¨æ·ºè‰²èƒŒæ™¯å¯è¦‹ */
        }
        /* é‡å°ã€Œç›®å‰æ²’æœ‰æé†’äº‹é …ã€çš„æç¤º */
        .text-gray-500 {
            color: #6b7280; /* æ¢å¾©æ·ºç°ï¼Œç¢ºä¿åœ¨æ·ºè‰²èƒŒæ™¯å¯è¦‹ */
        }
        /* é‡å°è‡ªå®šç¾©æ¨¡æ…‹æ¡†çš„æ³¨æ„æ¨™é¡Œ */
        .text-orange-600 {
            color: #D97940; /* äº®æ©˜è‰² */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">æˆ‘çš„æé†’äº‹é …</h1>

        <div class="input-section flex flex-col gap-4">
            <div class="input-group">
                <label for="reminderDate" class="block text-sm font-medium text-gray-700 mb-1">æ—¥æœŸ:</label>
                <input type="date" id="reminderDate" class="w-full">
                <span class="icon">ğŸ“…</span>
            </div>
            <div class="input-group">
                <label for="reminderTime" class="block text-sm font-medium text-gray-700 mb-1">æ™‚é–“:</label>
                <input type="time" id="reminderTime" class="w-full">
                <span class="icon">â°</span>
            </div>
            <div class="input-group">
                <label for="reminderEvent" class="block text-sm font-medium text-gray-700 mb-1">äº‹ä»¶:</label>
                <input type="text" id="reminderEvent" placeholder="è¼¸å…¥æé†’äº‹ä»¶..." class="w-full">
                <span class="icon">ğŸ“</span>
            </div>

            <div>
                <label for="repeatSelect" class="block text-sm font-medium text-gray-700 mb-1">é‡è¤‡:</label>
                <select id="repeatSelect" class="w-full">
                    <option value="once">åªæé†’ä¸€æ¬¡</option>
                    <option value="daily">æ¯å¤©</option>
                    <option value="weekdays">å¹³æ—¥ (é€±ä¸€è‡³é€±äº”)</option>
                    <option value="weekends">é€±æœ« (é€±å…­ã€é€±æ—¥)</option>
                    <option value="custom">è‡ªè¨‚</option>
                </select>
            </div>

            <div id="customRepeatDaysContainer" class="custom-repeat-days">
                <label><input type="checkbox" name="customDay" value="1"> é€±ä¸€</label>
                <label><input type="checkbox" name="customDay" value="2"> é€±äºŒ</label>
                <label><input type="checkbox" name="customDay" value="3"> é€±ä¸‰</label>
                <label><input type="checkbox" name="customDay" value="4"> é€±å››</label>
                <label><input type="checkbox" name="customDay" value="5"> é€±äº”</label>
                <label><input type="checkbox" name="customDay" value="6"> é€±å…­</label>
                <label><input type="checkbox" name="customDay" value="0"> é€±æ—¥</label>
            </div>

            <div>
                <label for="importanceSelect" class="block text-sm font-medium text-gray-700 mb-1">é‡è¦ç¨‹åº¦:</label>
                <select id="importanceSelect" class="w-full">
                    <option value="low">ä½</option>
                    <option value="medium" selected>ä¸­</option>
                    <option value="high">é«˜</option>
                </select>
            </div>

            <button id="addReminderBtn" class="w-full">æ–°å¢æé†’</button>
        </div>

        <div class="reminders-list-section mt-6">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">å¾…è¾¦æé†’</h2>
            <div id="remindersList" class="flex flex-col gap-3">
                <!-- Reminders will be loaded here -->
                <p class="text-gray-500 text-center" id="noRemindersMessage">ç›®å‰æ²’æœ‰æé†’äº‹é …ã€‚</p>
            </div>
        </div>

        <!-- ç”¨æˆ¶ ID é¡¯ç¤ºå€å¡Šï¼Œåœ¨é›¢ç·šæ¨¡å¼ä¸‹å·²ç§»é™¤ -->
        <!-- <div class="user-id-display">
            <p>ä½ çš„ç”¨æˆ¶ ID: <span id="currentUserId">è¼‰å…¥ä¸­...</span></p>
        </div> -->
    </div>

    <!-- Notification Modal -->
    <div id="notificationModal" class="notification-modal hidden">
        <div class="notification-content">
            <h2 class="text-orange-600">æé†’!</h2>
            <p id="notificationMessage">é€™æ˜¯ä¸€å€‹æé†’ã€‚</p>
            <button id="closeNotificationBtn">æˆ‘çŸ¥é“äº†</button>
        </div>
    </div>

    <script type="module">
        // å…¨åŸŸè®Šæ•¸ï¼Œå„²å­˜æé†’äº‹é …
        let reminders = [];
        const scheduledTimeouts = new Map(); // Map to store timeout IDs for clearing

        // DOM element references
        const reminderDateInput = document.getElementById('reminderDate');
        const reminderTimeInput = document.getElementById('reminderTime');
        const reminderEventInput = document.getElementById('reminderEvent');
        const repeatSelect = document.getElementById('repeatSelect');
        const customRepeatDaysContainer = document.getElementById('customRepeatDaysContainer');
        const customDayCheckboxes = document.querySelectorAll('input[name="customDay"]');
        const importanceSelect = document.getElementById('importanceSelect');
        const addReminderBtn = document.getElementById('addReminderBtn');
        const remindersList = document.getElementById('remindersList');
        const noRemindersMessage = document.getElementById('noRemindersMessage');
        const notificationModal = document.getElementById('notificationModal');
        const notificationMessage = document.getElementById('notificationMessage');
        const closeNotificationBtn = document.getElementById('closeNotificationBtn');

        // Local Storage Key
        const LOCAL_STORAGE_KEY = 'myRemindersApp';

        /**
         * å°‡æé†’äº‹é …å„²å­˜åˆ°ç€è¦½å™¨çš„ localStorage
         */
        function saveRemindersToLocalStorage() {
            try {
                localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(reminders));
                console.log("Reminders saved to local storage.");
            } catch (e) {
                console.error("Error saving reminders to local storage:", e);
                showCustomModal("å„²å­˜æé†’å¤±æ•—ï¼æ‚¨çš„ç€è¦½å™¨å„²å­˜ç©ºé–“å¯èƒ½ä¸è¶³æˆ–è¨­å®šæœ‰å•é¡Œã€‚");
            }
        }

        /**
         * å¾ç€è¦½å™¨çš„ localStorage è¼‰å…¥æé†’äº‹é …
         */
        function loadRemindersFromLocalStorage() {
            try {
                const storedReminders = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (storedReminders) {
                    reminders = JSON.parse(storedReminders);
                    // ç¢ºä¿è¼‰å…¥çš„æé†’äº‹é …æ˜¯æœ‰æ•ˆçš„ï¼Œä¸¦ä¸”é‡æ–°æ’ç¨‹
                    reminders = reminders.filter(r => r && r.id && r.event && r.timestamp);
                    reminders.sort((a, b) => a.timestamp - b.timestamp); // é‡æ–°æ’åº
                    console.log("Reminders loaded from local storage:", reminders);
                } else {
                    reminders = [];
                    console.log("No reminders found in local storage.");
                }
                renderReminders();
                reminders.forEach(scheduleReminder); // è¼‰å…¥å¾Œé‡æ–°æ’ç¨‹æ‰€æœ‰æé†’
            } catch (e) {
                console.error("Error loading reminders from local storage:", e);
                showCustomModal("è¼‰å…¥æé†’å¤±æ•—ï¼æ‚¨çš„ç€è¦½å™¨å„²å­˜ç©ºé–“å¯èƒ½å·²æå£ã€‚");
                reminders = []; // æ¸…ç©ºæé†’ï¼Œé¿å…é¡¯ç¤ºéŒ¯èª¤è³‡æ–™
                renderReminders();
            }
        }

        // Function to set the current date and time in the input fields
        function setInitialDateTime() {
            const now = new Date();

            // Format date toà´ªàµà´ªàµ†à´Ÿàµ†-MM-DD
            const year = now.getFullYear();
            const month = (now.getMonth() + 1).toString().padStart(2, '0'); // Months are 0-indexed
            const day = now.getDate().toString().padStart(2, '0');
            reminderDateInput.value = `${year}-${month}-${day}`;

            // Format time to HH:MM
            const hours = now.getHours().toString().padStart(2, '0');
            const minutes = now.getMinutes().toString().padStart(2, '0');
            reminderTimeInput.value = `${hours}:${minutes}`;
        }

        // Function to toggle custom repeat days visibility
        function toggleCustomRepeatDays() {
            if (repeatSelect.value === 'custom') {
                customRepeatDaysContainer.classList.add('active');
            } else {
                customRepeatDaysContainer.classList.remove('active');
                // Uncheck all custom day checkboxes when not in custom mode
                customDayCheckboxes.forEach(checkbox => checkbox.checked = false);
            }
        }

        /**
         * Calculates the next *future* occurrence of a reminder (especially for repeating ones).
         * This function ensures the returned timestamp is always in the future relative to the current time.
         * @param {object} reminder - The reminder object with original timestamp, repeatType, etc.
         * @returns {object|null} An object with `newTimestamp`, `newDateStr`, `newTimeStr` or null if no future occurrence can be found.
         */
        function calculateNextOccurrence(reminder) {
            const originalHour = new Date(reminder.timestamp).getHours();
            const originalMinute = new Date(reminder.timestamp).getMinutes();
            const now = new Date();

            let candidateDate = new Date(); // Start checking from current date
            candidateDate.setHours(originalHour, originalMinute, 0, 0); // Set time to reminder's original time

            // If today's reminder time (original hour:minute) is already past/current, advance to tomorrow.
            // This ensures we always start looking for a future date.
            if (candidateDate.getTime() <= now.getTime()) {
                candidateDate.setDate(candidateDate.getDate() + 1);
            }

            let foundNext = false;
            const maxSearchDays = 366 * 2; // Search up to 2 years to ensure we find a valid day for repeats

            for (let i = 0; i < maxSearchDays; i++) {
                // If it's not the first iteration, advance by one day.
                // This ensures we always check the current candidateDate *before* advancing for the next iteration.
                if (i > 0) {
                     candidateDate.setDate(candidateDate.getDate() + 1);
                }

                const dayOfWeek = candidateDate.getDay(); // 0 for Sunday, 6 for Saturday

                let isValidDayForRepeatType = false;
                switch (reminder.repeatType) {
                    case 'daily':
                        isValidDayForRepeatType = true;
                        break;
                    case 'weekdays':
                        isValidDayForRepeatType = (dayOfWeek >= 1 && dayOfWeek <= 5); // Monday to Friday
                        break;
                    case 'weekends':
                        isValidDayForRepeatType = (dayOfWeek === 0 || dayOfWeek === 6); // Sunday or Saturday
                        break;
                    case 'custom':
                        isValidDayForRepeatType = reminder.customRepeatDays && reminder.customRepeatDays.length > 0 && reminder.customRepeatDays.includes(dayOfWeek);
                        break;
                    case 'once':
                        // This function is primarily for repeating reminders.
                        // For 'once', if its original timestamp is already past 'now', there's no 'next' occurrence.
                        // If it's still in the future, its own timestamp is the 'next' occurrence.
                        // So we only return it if it's strictly in the future relative to the point this function is called.
                        return null;
                    default:
                        // Should not happen for valid repeat types
                        return null;
                }

                // After setting the candidateDate to the appropriate day, and if it's a valid day type,
                // check if its specific time (original hour:minute) is in the future.
                if (isValidDayForRepeatType && candidateDate.getTime() > now.getTime()) {
                    foundNext = true;
                    break;
                }
            }

            if (!foundNext) {
                console.warn("Could not find a future occurrence for repeating reminder after many iterations:", reminder);
                return null;
            }

            // Format the new date and time
            const newYear = candidateDate.getFullYear();
            const newMonth = (candidateDate.getMonth() + 1).toString().padStart(2, '0');
            const newDay = candidateDate.getDate().toString().padStart(2, '0');
            const newHours = candidateDate.getHours().toString().padStart(2, '0');
            const newMinutes = candidateDate.getMinutes().toString().padStart(2, '0');

            return {
                newTimestamp: candidateDate.getTime(),
                newDateStr: `${newYear}-${newMonth}-${newDay}`,
                newTimeStr: `${newHours}:${newMinutes}`
            };
        }

        // Function to add a new reminder
        function addReminder() {
            const dateStr = reminderDateInput.value;
            const timeStr = reminderTimeInput.value;
            const eventText = reminderEventInput.value.trim();
            const repeatType = repeatSelect.value;
            const importance = importanceSelect.value;
            let customRepeatDays = [];

            if (repeatType === 'custom') {
                customDayCheckboxes.forEach(checkbox => {
                    if (checkbox.checked) {
                        customRepeatDays.push(parseInt(checkbox.value, 10));
                    }
                });
                if (customRepeatDays.length === 0) {
                    showCustomModal("è«‹ç‚ºè‡ªè¨‚é‡è¤‡æé†’é¸æ“‡è‡³å°‘ä¸€å¤©ï¼");
                    return;
                }
            }

            if (!dateStr || !timeStr || !eventText) {
                showCustomModal("è«‹å¡«å¯«æ—¥æœŸã€æ™‚é–“å’Œäº‹ä»¶å…§å®¹ï¼");
                return;
            }

            const reminderDateTime = new Date(`${dateStr}T${timeStr}`);
            const now = new Date();

            // Initial validation for 'once' reminders: cannot be in the past.
            if (repeatType === 'once' && reminderDateTime.getTime() <= now.getTime()) {
                showCustomModal("å–®æ¬¡æé†’æ™‚é–“å¿…é ˆæ™šæ–¼ç¾åœ¨ï¼");
                return;
            }

            const newReminder = {
                id: Date.now().toString(), // åœ¨é›¢ç·šæ¨¡å¼ä¸‹ä½¿ç”¨æ™‚é–“æˆ³ä½œç‚ºå”¯ä¸€ ID
                event: eventText,
                date: dateStr,
                time: timeStr,
                timestamp: reminderDateTime.getTime(), // Initial timestamp from user input
                repeatType: repeatType,
                customRepeatDays: customRepeatDays,
                importance: importance,
                createdAt: Date.now()
            };

            // If it's a repeating reminder AND its initial timestamp is in the past,
            // calculate its first actual future occurrence and update the object before saving.
            if (newReminder.repeatType !== 'once' && newReminder.timestamp <= now.getTime()) {
                const nextOcc = calculateNextOccurrence(newReminder); // This call will find the next future occurrence
                if (nextOcc) {
                    newReminder.timestamp = nextOcc.newTimestamp;
                    newReminder.date = nextOcc.newDateStr;
                    newReminder.time = nextOcc.newTimeStr;
                    console.log("Repeating reminder adjusted to next occurrence during add:", nextOcc);
                } else {
                    showCustomModal("ç„¡æ³•ç‚ºé‡è¤‡æé†’æ‰¾åˆ°æœªä¾†çš„æ™‚é–“ï¼Œè«‹æª¢æŸ¥è¨­å®šï¼");
                    return;
                }
            }

            // ç›´æ¥å°‡æ–°æé†’åŠ å…¥é™£åˆ—
            reminders.push(newReminder);
            reminders.sort((a, b) => a.timestamp - b.timestamp); // é‡æ–°æ’åº

            saveRemindersToLocalStorage(); // å„²å­˜åˆ° localStorage
            renderReminders(); // é‡æ–°æ¸²æŸ“åˆ—è¡¨
            scheduleReminder(newReminder); // æ’ç¨‹æ–°æé†’

            // Clear input fields and reset selects
            setInitialDateTime(); // Reset date/time to current
            reminderEventInput.value = '';
            repeatSelect.value = 'once';
            importanceSelect.value = 'medium';
            toggleCustomRepeatDays(); // Hide custom days again
        }

        // Function to render the list of reminders
        function renderReminders() {
            remindersList.innerHTML = ''; // Clear existing list
            if (reminders.length === 0) {
                noRemindersMessage.style.display = 'block';
            } else {
                noRemindersMessage.style.display = 'none';
                reminders.forEach(reminder => {
                    const reminderItem = document.createElement('div');
                    reminderItem.className = 'reminder-item';

                    // Add importance class
                    if (reminder.importance) {
                        reminderItem.classList.add(`importance-${reminder.importance}`);
                    }

                    // Determine repeat text
                    let repeatText = '';
                    switch (reminder.repeatType) {
                        case 'once': repeatText = 'ä¸€æ¬¡'; break;
                        case 'daily': repeatText = 'æ¯å¤©é‡è¤‡'; break;
                        case 'weekdays': repeatText = 'å¹³æ—¥é‡è¤‡'; break;
                        case 'weekends': repeatText = 'é€±æœ«é‡è¤‡'; break;
                        case 'custom':
                            if (reminder.customRepeatDays && reminder.customRepeatDays.length > 0) {
                                const dayNames = ['é€±æ—¥', 'é€±ä¸€', 'é€±äºŒ', 'é€±ä¸‰', 'é€±å››', 'é€±äº”', 'é€±å…­'];
                                const selectedDays = reminder.customRepeatDays.map(day => dayNames[day]).join('ã€');
                                repeatText = `è‡ªè¨‚é‡è¤‡: ${selectedDays}`;
                            } else {
                                repeatText = 'è‡ªè¨‚é‡è¤‡ (æœªè¨­å®š)';
                            }
                            break;
                    }


                    reminderItem.innerHTML = `
                        <div class="header-row">
                            <span class="event-text flex-grow">${reminder.event}</span>
                            <span class="importance-tag importance-${reminder.importance}">${reminder.importance === 'low' ? 'ä½' : (reminder.importance === 'medium' ? 'ä¸­' : 'é«˜')}</span>
                        </div>
                        <div class="details-row">
                            <span class="datetime-text">${reminder.date} ${reminder.time}</span>
                            <span class="repeat-text">é‡è¤‡: ${repeatText}</span>
                            <button class="delete-btn" data-id="${reminder.id}">åˆªé™¤</button>
                        </div>
                    `;
                    remindersList.appendChild(reminderItem);
                });
            }
        }

        // Function to play a simple beep sound using Web Audio API
        function playBeepSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.type = 'sine'; // Sine wave for a clean beep
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // A4 note (440 Hz)

                gainNode.gain.setValueAtTime(1, audioContext.currentTime);
                // Exponential ramp to 0.001 (near silent) over 0.5 seconds
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5); // Play for 0.5 seconds
            } catch (e) {
                console.error("Error playing beep sound:", e);
                // Optionally show a visual alert if sound fails, but console error is usually enough
            }
        }


        // Function to schedule a single reminder
        function scheduleReminder(reminder) {
            // Clear existing timeout for this reminder if it was rescheduled or updated
            if (scheduledTimeouts.has(reminder.id)) {
                clearTimeout(scheduledTimeouts.get(reminder.id));
                scheduledTimeouts.delete(reminder.id);
            }

            const now = Date.now();
            let delay = reminder.timestamp - now;

            // Handle reminders that are already past or current
            if (delay <= 0) {
                if (reminder.repeatType !== 'once') {
                    // å°æ–¼é‡è¤‡æé†’ï¼šæ‰¾åˆ°ä¸‹ä¸€å€‹æœªä¾†çš„ç™¼ç”Ÿæ™‚é–“
                    const nextOcc = calculateNextOccurrence(reminder);
                    if (nextOcc) {
                        console.log(`Repeating reminder "${reminder.event}" is past/current. Rescheduling to:`, nextOcc.newDateStr, nextOcc.newTimeStr);
                        // æ›´æ–°é™£åˆ—ä¸­çš„æé†’äº‹é …
                        const index = reminders.findIndex(r => r.id === reminder.id);
                        if (index !== -1) {
                            reminders[index].timestamp = nextOcc.newTimestamp;
                            reminders[index].date = nextOcc.newDateStr;
                            reminders[index].time = nextOcc.newTimeStr;
                            saveRemindersToLocalStorage(); // å„²å­˜æ›´æ–°
                            renderReminders(); // é‡æ–°æ¸²æŸ“åˆ—è¡¨
                            scheduleReminder(reminders[index]); // é‡æ–°æ’ç¨‹æ›´æ–°å¾Œçš„æé†’
                        }
                        return;
                    } else {
                        console.log(`Repeating reminder "${reminder.event}" has no future occurrences or is misconfigured. Deleting.`);
                        deleteReminder(reminder.id); // ç„¡æ³•æ‰¾åˆ°ä¸‹ä¸€å€‹ç™¼ç”Ÿæ™‚é–“ï¼Œå‰‡åˆªé™¤
                        return;
                    }
                } else {
                    // å°æ–¼å–®æ¬¡æé†’ï¼šå¦‚æœå·²éæœŸï¼Œå‰‡åˆªé™¤
                    console.log(`One-time reminder "${reminder.event}" is past. Deleting.`);
                    deleteReminder(reminder.id);
                    return;
                }
            }

            // å¦‚æœæé†’ä»åœ¨æœªä¾†ï¼Œå‰‡æ’ç¨‹
            if (delay > 0) {
                const timeoutId = setTimeout(() => {
                    showNotification(reminder);
                    playBeepSound(); // æé†’å½ˆå‡ºæ™‚æ’­æ”¾éŸ³æ•ˆ

                    if (reminder.repeatType !== 'once') {
                        // å°æ–¼é‡è¤‡æé†’ï¼šè§¸ç™¼å¾Œï¼Œè¨ˆç®—ä¸¦æ›´æ–°åˆ°ä¸‹ä¸€å€‹ç™¼ç”Ÿæ™‚é–“
                        const nextOcc = calculateNextOccurrence(reminder);
                        if (nextOcc) {
                            console.log(`Reminder "${reminder.event}" fired. Scheduling next occurrence:`, nextOcc.newDateStr, nextOcc.newTimeStr);
                            const index = reminders.findIndex(r => r.id === reminder.id);
                            if (index !== -1) {
                                reminders[index].timestamp = nextOcc.newTimestamp;
                                reminders[index].date = nextOcc.newDateStr;
                                reminders[index].time = nextOcc.newTimeStr;
                                saveRemindersToLocalStorage(); // å„²å­˜æ›´æ–°
                                renderReminders(); // é‡æ–°æ¸²æŸ“åˆ—è¡¨
                                scheduleReminder(reminders[index]); // é‡æ–°æ’ç¨‹æ›´æ–°å¾Œçš„æé†’
                            }
                        } else {
                            console.log(`Repeating reminder "${reminder.event}" has no further occurrences. Deleting.`);
                            deleteReminder(reminder.id); // å¦‚æœæ²’æœ‰ä¸‹ä¸€å€‹ç™¼ç”Ÿæ™‚é–“ï¼Œå‰‡åˆªé™¤
                        }
                    } else {
                        // å°æ–¼å–®æ¬¡æé†’ï¼šé€šçŸ¥å¾Œåˆªé™¤
                        console.log(`One-time reminder "${reminder.event}" fired. Deleting.`);
                        deleteReminder(reminder.id);
                    }
                }, delay);
                scheduledTimeouts.set(reminder.id, timeoutId);
            }
        }

        // Function to show the notification modal
        function showNotification(reminder) {
            notificationMessage.textContent = `ã€Œ${reminder.event}ã€æ–¼ ${reminder.date} ${reminder.time} åˆ°æœŸäº†ï¼`;
            notificationModal.classList.remove('hidden');
            notificationModal.classList.add('active');
        }

        // Function to show a custom modal for alert messages (replaces native alert)
        function showCustomModal(message) {
            const customModal = document.createElement('div');
            customModal.className = 'notification-modal active'; // Reuse notification modal styling
            customModal.innerHTML = `
                <div class="notification-content">
                    <h2 class="text-orange-600">æ³¨æ„!</h2>
                    <p>${message}</p>
                    <button id="customModalCloseBtn">ç¢ºèª</button>
                </div>
            `;
            document.body.appendChild(customModal);

            const customModalCloseBtn = customModal.querySelector('#customModalCloseBtn');
            customModalCloseBtn.addEventListener('click', () => {
                customModal.classList.remove('active');
                setTimeout(() => customModal.remove(), 300); // Remove after transition
            });
        }

        // Function to delete a reminder
        function deleteReminder(id) {
            // Clear the scheduled timeout if it exists
            if (scheduledTimeouts.has(id)) {
                clearTimeout(scheduledTimeouts.get(id));
                scheduledTimeouts.delete(id);
            }

            // å¾é™£åˆ—ä¸­ç§»é™¤æé†’äº‹é …
            reminders = reminders.filter(reminder => reminder.id !== id);
            saveRemindersToLocalStorage(); // å„²å­˜æ›´æ–°
            renderReminders(); // é‡æ–°æ¸²æŸ“åˆ—è¡¨
            console.log("Reminder successfully deleted!");
        }

        // Event listeners
        addReminderBtn.addEventListener('click', addReminder);
        repeatSelect.addEventListener('change', toggleCustomRepeatDays);
        closeNotificationBtn.addEventListener('click', () => {
            notificationModal.classList.add('hidden');
            notificationModal.classList.remove('active');
        });

        // Event delegation for delete buttons in the list
        remindersList.addEventListener('click', (event) => {
            if (event.target.classList.contains('delete-btn')) {
                const reminderId = event.target.dataset.id;
                deleteReminder(reminderId);
            }
        });

        // Initialize on window load
        window.onload = () => {
            setInitialDateTime(); // Set date and time when the page loads
            toggleCustomRepeatDays(); // Set initial visibility for custom repeat days
            loadRemindersFromLocalStorage(); // è¼‰å…¥æœ¬åœ°å„²å­˜çš„æé†’äº‹é …
        };
    </script>
</body>
</html>
